// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package user_repository_mock

//go:generate minimock -i github.com/justbrownbear/microservices_course_auth/internal/repository/user.UserRepository -o user_repository_minimock.go -n UserRepositoryMock -p user_repository_mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
	mm_user_repository "github.com/justbrownbear/microservices_course_auth/internal/repository/user"
)

// UserRepositoryMock implements mm_user_repository.UserRepository
type UserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, arg mm_user_repository.CreateUserParams) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, arg mm_user_repository.CreateUserParams)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserRepositoryMockCreateUser

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mUserRepositoryMockDeleteUser

	funcGetUser          func(ctx context.Context, id int64) (g1 mm_user_repository.GetUserRow, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserRepositoryMockGetUser

	funcUpdateUser          func(ctx context.Context, arg mm_user_repository.UpdateUserParams) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, arg mm_user_repository.UpdateUserParams)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mUserRepositoryMockUpdateUser

	funcWithTx          func(tx pgx.Tx) (qp1 *mm_user_repository.Queries)
	funcWithTxOrigin    string
	inspectFuncWithTx   func(tx pgx.Tx)
	afterWithTxCounter  uint64
	beforeWithTxCounter uint64
	WithTxMock          mUserRepositoryMockWithTx
}

// NewUserRepositoryMock returns a mock for mm_user_repository.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserRepositoryMockCreateUserParams{}

	m.DeleteUserMock = mUserRepositoryMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*UserRepositoryMockDeleteUserParams{}

	m.GetUserMock = mUserRepositoryMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserRepositoryMockGetUserParams{}

	m.UpdateUserMock = mUserRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*UserRepositoryMockUpdateUserParams{}

	m.WithTxMock = mUserRepositoryMockWithTx{mock: m}
	m.WithTxMock.callArgs = []*UserRepositoryMockWithTxParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRepositoryMockCreateUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateUserExpectation
	expectations       []*UserRepositoryMockCreateUserExpectation

	callArgs []*UserRepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockCreateUserExpectation specifies expectation struct of the UserRepository.CreateUser
type UserRepositoryMockCreateUserExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockCreateUserParams
	paramPtrs          *UserRepositoryMockCreateUserParamPtrs
	expectationOrigins UserRepositoryMockCreateUserExpectationOrigins
	results            *UserRepositoryMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockCreateUserParams contains parameters of the UserRepository.CreateUser
type UserRepositoryMockCreateUserParams struct {
	ctx context.Context
	arg mm_user_repository.CreateUserParams
}

// UserRepositoryMockCreateUserParamPtrs contains pointers to parameters of the UserRepository.CreateUser
type UserRepositoryMockCreateUserParamPtrs struct {
	ctx *context.Context
	arg *mm_user_repository.CreateUserParams
}

// UserRepositoryMockCreateUserResults contains results of the UserRepository.CreateUser
type UserRepositoryMockCreateUserResults struct {
	i1  int64
	err error
}

// UserRepositoryMockCreateUserOrigins contains origins of expectations of the UserRepository.CreateUser
type UserRepositoryMockCreateUserExpectationOrigins struct {
	origin    string
	originCtx string
	originArg string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserRepositoryMockCreateUser) Optional() *mUserRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Expect(ctx context.Context, arg mm_user_repository.CreateUserParams) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserRepositoryMockCreateUserParams{ctx, arg}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectArgParam2 sets up expected param arg for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) ExpectArgParam2(arg mm_user_repository.CreateUserParams) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.arg = &arg
	mmCreateUser.defaultExpectation.expectationOrigins.originArg = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Inspect(f func(ctx context.Context, arg mm_user_repository.CreateUserParams)) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Return(i1 int64, err error) *UserRepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserRepositoryMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserRepository.CreateUser method
func (mmCreateUser *mUserRepositoryMockCreateUser) Set(f func(ctx context.Context, arg mm_user_repository.CreateUserParams) (i1 int64, err error)) *UserRepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the UserRepository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserRepositoryMockCreateUser) When(ctx context.Context, arg mm_user_repository.CreateUserParams) *UserRepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &UserRepositoryMockCreateUserParams{ctx, arg},
		expectationOrigins: UserRepositoryMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateUserExpectation) Then(i1 int64, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times UserRepository.CreateUser should be invoked
func (mmCreateUser *mUserRepositoryMockCreateUser) Times(n uint64) *mUserRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserRepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mUserRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_user_repository.UserRepository
func (mmCreateUser *UserRepositoryMock) CreateUser(ctx context.Context, arg mm_user_repository.CreateUserParams) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, arg)
	}

	mm_params := UserRepositoryMockCreateUserParams{ctx, arg}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockCreateUserParams{ctx, arg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.arg != nil && !minimock.Equal(*mm_want_ptrs.arg, mm_got.arg) {
				mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameter arg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originArg, *mm_want_ptrs.arg, mm_got.arg, minimock.Diff(*mm_want_ptrs.arg, mm_got.arg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserRepositoryMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, arg)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserRepositoryMock.CreateUser. %v %v", ctx, arg)
	return
}

// CreateUserAfterCounter returns a count of finished UserRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserRepositoryMockCreateUser) Calls() []*UserRepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mUserRepositoryMockDeleteUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteUserExpectation
	expectations       []*UserRepositoryMockDeleteUserExpectation

	callArgs []*UserRepositoryMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockDeleteUserExpectation specifies expectation struct of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockDeleteUserParams
	paramPtrs          *UserRepositoryMockDeleteUserParamPtrs
	expectationOrigins UserRepositoryMockDeleteUserExpectationOrigins
	results            *UserRepositoryMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockDeleteUserParams contains parameters of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryMockDeleteUserParamPtrs contains pointers to parameters of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryMockDeleteUserResults contains results of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserResults struct {
	err error
}

// UserRepositoryMockDeleteUserOrigins contains origins of expectations of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Optional() *mUserRepositoryMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Expect(ctx context.Context, id int64) *mUserRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &UserRepositoryMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) ExpectIdParam2(id int64) *mUserRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Return(err error) *UserRepositoryMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &UserRepositoryMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the UserRepository.DeleteUser method
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *UserRepositoryMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the UserRepository.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserRepositoryMockDeleteUser) When(ctx context.Context, id int64) *UserRepositoryMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &UserRepositoryMockDeleteUserParams{ctx, id},
		expectationOrigins: UserRepositoryMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteUserExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times UserRepository.DeleteUser should be invoked
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Times(n uint64) *mUserRepositoryMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of UserRepositoryMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mUserRepositoryMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_user_repository.UserRepository
func (mmDeleteUser *UserRepositoryMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := UserRepositoryMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("UserRepositoryMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("UserRepositoryMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("UserRepositoryMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the UserRepositoryMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to UserRepositoryMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished UserRepositoryMock.DeleteUser invocations
func (mmDeleteUser *UserRepositoryMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of UserRepositoryMock.DeleteUser invocations
func (mmDeleteUser *UserRepositoryMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Calls() []*UserRepositoryMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mUserRepositoryMockGetUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetUserExpectation
	expectations       []*UserRepositoryMockGetUserExpectation

	callArgs []*UserRepositoryMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockGetUserExpectation specifies expectation struct of the UserRepository.GetUser
type UserRepositoryMockGetUserExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockGetUserParams
	paramPtrs          *UserRepositoryMockGetUserParamPtrs
	expectationOrigins UserRepositoryMockGetUserExpectationOrigins
	results            *UserRepositoryMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockGetUserParams contains parameters of the UserRepository.GetUser
type UserRepositoryMockGetUserParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryMockGetUserParamPtrs contains pointers to parameters of the UserRepository.GetUser
type UserRepositoryMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryMockGetUserResults contains results of the UserRepository.GetUser
type UserRepositoryMockGetUserResults struct {
	g1  mm_user_repository.GetUserRow
	err error
}

// UserRepositoryMockGetUserOrigins contains origins of expectations of the UserRepository.GetUser
type UserRepositoryMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserRepositoryMockGetUser) Optional() *mUserRepositoryMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for UserRepository.GetUser
func (mmGetUser *mUserRepositoryMockGetUser) Expect(ctx context.Context, id int64) *mUserRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserRepositoryMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetUser
func (mmGetUser *mUserRepositoryMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for UserRepository.GetUser
func (mmGetUser *mUserRepositoryMockGetUser) ExpectIdParam2(id int64) *mUserRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetUser
func (mmGetUser *mUserRepositoryMockGetUser) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by UserRepository.GetUser
func (mmGetUser *mUserRepositoryMockGetUser) Return(g1 mm_user_repository.GetUserRow, err error) *UserRepositoryMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRepositoryMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserRepositoryMockGetUserResults{g1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the UserRepository.GetUser method
func (mmGetUser *mUserRepositoryMockGetUser) Set(f func(ctx context.Context, id int64) (g1 mm_user_repository.GetUserRow, err error)) *UserRepositoryMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the UserRepository.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserRepositoryMockGetUser) When(ctx context.Context, id int64) *UserRepositoryMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryMock.GetUser mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &UserRepositoryMockGetUserParams{ctx, id},
		expectationOrigins: UserRepositoryMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetUserExpectation) Then(g1 mm_user_repository.GetUserRow, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetUserResults{g1, err}
	return e.mock
}

// Times sets number of times UserRepository.GetUser should be invoked
func (mmGetUser *mUserRepositoryMockGetUser) Times(n uint64) *mUserRepositoryMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserRepositoryMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mUserRepositoryMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_user_repository.UserRepository
func (mmGetUser *UserRepositoryMock) GetUser(ctx context.Context, id int64) (g1 mm_user_repository.GetUserRow, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := UserRepositoryMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.g1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserRepositoryMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("UserRepositoryMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserRepositoryMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserRepositoryMock.GetUser")
		}
		return (*mm_results).g1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserRepositoryMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished UserRepositoryMock.GetUser invocations
func (mmGetUser *UserRepositoryMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserRepositoryMock.GetUser invocations
func (mmGetUser *UserRepositoryMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserRepositoryMockGetUser) Calls() []*UserRepositoryMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mUserRepositoryMockUpdateUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockUpdateUserExpectation
	expectations       []*UserRepositoryMockUpdateUserExpectation

	callArgs []*UserRepositoryMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockUpdateUserExpectation specifies expectation struct of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockUpdateUserParams
	paramPtrs          *UserRepositoryMockUpdateUserParamPtrs
	expectationOrigins UserRepositoryMockUpdateUserExpectationOrigins
	results            *UserRepositoryMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockUpdateUserParams contains parameters of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserParams struct {
	ctx context.Context
	arg mm_user_repository.UpdateUserParams
}

// UserRepositoryMockUpdateUserParamPtrs contains pointers to parameters of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserParamPtrs struct {
	ctx *context.Context
	arg *mm_user_repository.UpdateUserParams
}

// UserRepositoryMockUpdateUserResults contains results of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserResults struct {
	err error
}

// UserRepositoryMockUpdateUserOrigins contains origins of expectations of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserExpectationOrigins struct {
	origin    string
	originCtx string
	originArg string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Optional() *mUserRepositoryMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Expect(ctx context.Context, arg mm_user_repository.UpdateUserParams) *mUserRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &UserRepositoryMockUpdateUserParams{ctx, arg}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectArgParam2 sets up expected param arg for UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) ExpectArgParam2(arg mm_user_repository.UpdateUserParams) *mUserRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.arg = &arg
	mmUpdateUser.defaultExpectation.expectationOrigins.originArg = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Inspect(f func(ctx context.Context, arg mm_user_repository.UpdateUserParams)) *mUserRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Return(err error) *UserRepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &UserRepositoryMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the UserRepository.UpdateUser method
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Set(f func(ctx context.Context, arg mm_user_repository.UpdateUserParams) (err error)) *UserRepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the UserRepository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUserRepositoryMockUpdateUser) When(ctx context.Context, arg mm_user_repository.UpdateUserParams) *UserRepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &UserRepositoryMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &UserRepositoryMockUpdateUserParams{ctx, arg},
		expectationOrigins: UserRepositoryMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUpdateUserExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times UserRepository.UpdateUser should be invoked
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Times(n uint64) *mUserRepositoryMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of UserRepositoryMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mUserRepositoryMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_user_repository.UserRepository
func (mmUpdateUser *UserRepositoryMock) UpdateUser(ctx context.Context, arg mm_user_repository.UpdateUserParams) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, arg)
	}

	mm_params := UserRepositoryMockUpdateUserParams{ctx, arg}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockUpdateUserParams{ctx, arg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("UserRepositoryMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.arg != nil && !minimock.Equal(*mm_want_ptrs.arg, mm_got.arg) {
				mmUpdateUser.t.Errorf("UserRepositoryMock.UpdateUser got unexpected parameter arg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originArg, *mm_want_ptrs.arg, mm_got.arg, minimock.Diff(*mm_want_ptrs.arg, mm_got.arg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("UserRepositoryMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the UserRepositoryMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, arg)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to UserRepositoryMock.UpdateUser. %v %v", ctx, arg)
	return
}

// UpdateUserAfterCounter returns a count of finished UserRepositoryMock.UpdateUser invocations
func (mmUpdateUser *UserRepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of UserRepositoryMock.UpdateUser invocations
func (mmUpdateUser *UserRepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Calls() []*UserRepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

type mUserRepositoryMockWithTx struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockWithTxExpectation
	expectations       []*UserRepositoryMockWithTxExpectation

	callArgs []*UserRepositoryMockWithTxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockWithTxExpectation specifies expectation struct of the UserRepository.WithTx
type UserRepositoryMockWithTxExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockWithTxParams
	paramPtrs          *UserRepositoryMockWithTxParamPtrs
	expectationOrigins UserRepositoryMockWithTxExpectationOrigins
	results            *UserRepositoryMockWithTxResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockWithTxParams contains parameters of the UserRepository.WithTx
type UserRepositoryMockWithTxParams struct {
	tx pgx.Tx
}

// UserRepositoryMockWithTxParamPtrs contains pointers to parameters of the UserRepository.WithTx
type UserRepositoryMockWithTxParamPtrs struct {
	tx *pgx.Tx
}

// UserRepositoryMockWithTxResults contains results of the UserRepository.WithTx
type UserRepositoryMockWithTxResults struct {
	qp1 *mm_user_repository.Queries
}

// UserRepositoryMockWithTxOrigins contains origins of expectations of the UserRepository.WithTx
type UserRepositoryMockWithTxExpectationOrigins struct {
	origin   string
	originTx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithTx *mUserRepositoryMockWithTx) Optional() *mUserRepositoryMockWithTx {
	mmWithTx.optional = true
	return mmWithTx
}

// Expect sets up expected params for UserRepository.WithTx
func (mmWithTx *mUserRepositoryMockWithTx) Expect(tx pgx.Tx) *mUserRepositoryMockWithTx {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("UserRepositoryMock.WithTx mock is already set by Set")
	}

	if mmWithTx.defaultExpectation == nil {
		mmWithTx.defaultExpectation = &UserRepositoryMockWithTxExpectation{}
	}

	if mmWithTx.defaultExpectation.paramPtrs != nil {
		mmWithTx.mock.t.Fatalf("UserRepositoryMock.WithTx mock is already set by ExpectParams functions")
	}

	mmWithTx.defaultExpectation.params = &UserRepositoryMockWithTxParams{tx}
	mmWithTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithTx.expectations {
		if minimock.Equal(e.params, mmWithTx.defaultExpectation.params) {
			mmWithTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithTx.defaultExpectation.params)
		}
	}

	return mmWithTx
}

// ExpectTxParam1 sets up expected param tx for UserRepository.WithTx
func (mmWithTx *mUserRepositoryMockWithTx) ExpectTxParam1(tx pgx.Tx) *mUserRepositoryMockWithTx {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("UserRepositoryMock.WithTx mock is already set by Set")
	}

	if mmWithTx.defaultExpectation == nil {
		mmWithTx.defaultExpectation = &UserRepositoryMockWithTxExpectation{}
	}

	if mmWithTx.defaultExpectation.params != nil {
		mmWithTx.mock.t.Fatalf("UserRepositoryMock.WithTx mock is already set by Expect")
	}

	if mmWithTx.defaultExpectation.paramPtrs == nil {
		mmWithTx.defaultExpectation.paramPtrs = &UserRepositoryMockWithTxParamPtrs{}
	}
	mmWithTx.defaultExpectation.paramPtrs.tx = &tx
	mmWithTx.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmWithTx
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.WithTx
func (mmWithTx *mUserRepositoryMockWithTx) Inspect(f func(tx pgx.Tx)) *mUserRepositoryMockWithTx {
	if mmWithTx.mock.inspectFuncWithTx != nil {
		mmWithTx.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.WithTx")
	}

	mmWithTx.mock.inspectFuncWithTx = f

	return mmWithTx
}

// Return sets up results that will be returned by UserRepository.WithTx
func (mmWithTx *mUserRepositoryMockWithTx) Return(qp1 *mm_user_repository.Queries) *UserRepositoryMock {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("UserRepositoryMock.WithTx mock is already set by Set")
	}

	if mmWithTx.defaultExpectation == nil {
		mmWithTx.defaultExpectation = &UserRepositoryMockWithTxExpectation{mock: mmWithTx.mock}
	}
	mmWithTx.defaultExpectation.results = &UserRepositoryMockWithTxResults{qp1}
	mmWithTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithTx.mock
}

// Set uses given function f to mock the UserRepository.WithTx method
func (mmWithTx *mUserRepositoryMockWithTx) Set(f func(tx pgx.Tx) (qp1 *mm_user_repository.Queries)) *UserRepositoryMock {
	if mmWithTx.defaultExpectation != nil {
		mmWithTx.mock.t.Fatalf("Default expectation is already set for the UserRepository.WithTx method")
	}

	if len(mmWithTx.expectations) > 0 {
		mmWithTx.mock.t.Fatalf("Some expectations are already set for the UserRepository.WithTx method")
	}

	mmWithTx.mock.funcWithTx = f
	mmWithTx.mock.funcWithTxOrigin = minimock.CallerInfo(1)
	return mmWithTx.mock
}

// When sets expectation for the UserRepository.WithTx which will trigger the result defined by the following
// Then helper
func (mmWithTx *mUserRepositoryMockWithTx) When(tx pgx.Tx) *UserRepositoryMockWithTxExpectation {
	if mmWithTx.mock.funcWithTx != nil {
		mmWithTx.mock.t.Fatalf("UserRepositoryMock.WithTx mock is already set by Set")
	}

	expectation := &UserRepositoryMockWithTxExpectation{
		mock:               mmWithTx.mock,
		params:             &UserRepositoryMockWithTxParams{tx},
		expectationOrigins: UserRepositoryMockWithTxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithTx.expectations = append(mmWithTx.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.WithTx return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockWithTxExpectation) Then(qp1 *mm_user_repository.Queries) *UserRepositoryMock {
	e.results = &UserRepositoryMockWithTxResults{qp1}
	return e.mock
}

// Times sets number of times UserRepository.WithTx should be invoked
func (mmWithTx *mUserRepositoryMockWithTx) Times(n uint64) *mUserRepositoryMockWithTx {
	if n == 0 {
		mmWithTx.mock.t.Fatalf("Times of UserRepositoryMock.WithTx mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithTx.expectedInvocations, n)
	mmWithTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithTx
}

func (mmWithTx *mUserRepositoryMockWithTx) invocationsDone() bool {
	if len(mmWithTx.expectations) == 0 && mmWithTx.defaultExpectation == nil && mmWithTx.mock.funcWithTx == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithTx.mock.afterWithTxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithTx.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithTx implements mm_user_repository.UserRepository
func (mmWithTx *UserRepositoryMock) WithTx(tx pgx.Tx) (qp1 *mm_user_repository.Queries) {
	mm_atomic.AddUint64(&mmWithTx.beforeWithTxCounter, 1)
	defer mm_atomic.AddUint64(&mmWithTx.afterWithTxCounter, 1)

	mmWithTx.t.Helper()

	if mmWithTx.inspectFuncWithTx != nil {
		mmWithTx.inspectFuncWithTx(tx)
	}

	mm_params := UserRepositoryMockWithTxParams{tx}

	// Record call args
	mmWithTx.WithTxMock.mutex.Lock()
	mmWithTx.WithTxMock.callArgs = append(mmWithTx.WithTxMock.callArgs, &mm_params)
	mmWithTx.WithTxMock.mutex.Unlock()

	for _, e := range mmWithTx.WithTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.qp1
		}
	}

	if mmWithTx.WithTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithTx.WithTxMock.defaultExpectation.Counter, 1)
		mm_want := mmWithTx.WithTxMock.defaultExpectation.params
		mm_want_ptrs := mmWithTx.WithTxMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockWithTxParams{tx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmWithTx.t.Errorf("UserRepositoryMock.WithTx got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithTx.t.Errorf("UserRepositoryMock.WithTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithTx.WithTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithTx.WithTxMock.defaultExpectation.results
		if mm_results == nil {
			mmWithTx.t.Fatal("No results are set for the UserRepositoryMock.WithTx")
		}
		return (*mm_results).qp1
	}
	if mmWithTx.funcWithTx != nil {
		return mmWithTx.funcWithTx(tx)
	}
	mmWithTx.t.Fatalf("Unexpected call to UserRepositoryMock.WithTx. %v", tx)
	return
}

// WithTxAfterCounter returns a count of finished UserRepositoryMock.WithTx invocations
func (mmWithTx *UserRepositoryMock) WithTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithTx.afterWithTxCounter)
}

// WithTxBeforeCounter returns a count of UserRepositoryMock.WithTx invocations
func (mmWithTx *UserRepositoryMock) WithTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithTx.beforeWithTxCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.WithTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithTx *mUserRepositoryMockWithTx) Calls() []*UserRepositoryMockWithTxParams {
	mmWithTx.mutex.RLock()

	argCopy := make([]*UserRepositoryMockWithTxParams, len(mmWithTx.callArgs))
	copy(argCopy, mmWithTx.callArgs)

	mmWithTx.mutex.RUnlock()

	return argCopy
}

// MinimockWithTxDone returns true if the count of the WithTx invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockWithTxDone() bool {
	if m.WithTxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithTxMock.invocationsDone()
}

// MinimockWithTxInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockWithTxInspect() {
	for _, e := range m.WithTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.WithTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithTxCounter := mm_atomic.LoadUint64(&m.afterWithTxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithTxMock.defaultExpectation != nil && afterWithTxCounter < 1 {
		if m.WithTxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.WithTx at\n%s", m.WithTxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.WithTx at\n%s with params: %#v", m.WithTxMock.defaultExpectation.expectationOrigins.origin, *m.WithTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithTx != nil && afterWithTxCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.WithTx at\n%s", m.funcWithTxOrigin)
	}

	if !m.WithTxMock.invocationsDone() && afterWithTxCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.WithTx at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithTxMock.expectedInvocations), m.WithTxMock.expectedInvocationsOrigin, afterWithTxCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetUserInspect()

			m.MinimockUpdateUserInspect()

			m.MinimockWithTxInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockUpdateUserDone() &&
		m.MinimockWithTxDone()
}
